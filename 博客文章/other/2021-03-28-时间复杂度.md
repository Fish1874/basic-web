## 时间复杂度

> 在代码中，通常用大 O 表示事件复杂度！
>
> - 大 O 时间复杂度实际上并非代码真正的执行时间，而是表示代码执行时间随着数据规模增长的变化趋势，大白话：{ ***随着输入大小的增长，运行时间会以怎样的速度扩张。*** }
>
> 所以，也叫**渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**

![](C:\Users\wilson\Desktop\每日博客\images\其它\时间复杂度.png)

O(1)速度最快，因为永远都是固定的时间。

O(1)  <  O(logN)  <  O(N)  <  O(NlogN) <  O(N²)

## 如何计算时间频率

> **代码运行的时间T(n) 与每行代码的执行次数n成正比。**
>
> T(n) = O(f(n))
>
> - T(n) 表示执行代码的时间
> - n 表示数据规模的大小
> - f(n) 表示每行代码执行的次数总和

1. 先计算 代码运行次数 T(n)
2. 再转为 时间复杂度

举例：

```
1. 去掉常数项
T(n) = 5n² + 10n + 7;   # 去掉7

2. 去掉低阶项
T(n) = 5n² + 10n;       # 去掉 10n

3. 去掉高阶次项系数
T(n) = 5n²              # 去掉 5

变为：
T(n) = n²

∵ T(n) = O(f(n))
∴ 时间复杂度：O(N²)

/*
 * 公式中的低阶、常量、系数三部分并不会左右增长趋势，所以都可以忽略。
*/

```





## 复杂度量级

### O( *1* )

> 运行时间和输入大小无关，都在固定时间内算完。

```javascript
function fn(num) {
    let i = num, j = num * 2;
	return i + j
}

/* 不管num为多少，都是固定的时间，
 * 因为代码的执行时间不会随着num的大小增大而增大！
*/

```

### O( *N* )

> 随着输入规模的增加，运行时间**线性增加**。

```javascript
function fn(num) {
    let total = 0 // 常量不看
	for (let i = 0; i < num.length; i++) { // 从0~num循环
	     total += i  
    }
	return total
}

/* 代码的执行时间会随着num的大小增大而增大！
 * 取决于num的大小，所以时间复杂度就是 O(N)。
*/
```



### O( M+N )

```javascript
function fn(num1, num2) {
    let total = 0 // 常量不看
	for (let i = 0; i < num1.length; i++) {
	     total += i
    }
	for (let j = 0; j < num2.length; j++) {
	     total += j  
    }    
	return total
}
/* 这就是两个循环并列
*/

```



### O( *N²* )

> 随着输入规模的增加，运行时间**次方增加**。

```javascript
function fn(num) {
    let total = 0 
	for (let i = 0; i < num.length; i++) { 
	   	for (let j = 0; j < num.length; j++) { 
	       total += i+j;
    	}    
    }
	return total
}
/* 两个循环嵌套
 * n*n  => O(N²)
*/
```



### O( *log(N)* )

> 随着输入规模翻倍，操作次数只增加一。

[《国王赏麦》举列子：](https://zhuanlan.zhihu.com/p/248284657)

- 传说西塔发明了国际象棋而使国王十分高兴，他决定要重赏西塔。西塔说：“我不要你的重赏，陛下，只要你在我的棋盘上赏一些麦子就行了。在棋盘的第1个格子里放1粒，在第2个格子里放2粒，在第3个格子里放4粒，在第4个格子里放8粒，依此类推，以 后每一个格子里放的麦粒数都是前一个格子里放的麦粒数的2倍，直到放满第64个格子就行了”。区区小数，几粒麦子，这有何难，“来人”，国王令人如数付给西塔。计数麦粒的工作开始了，第一格内放1粒，第二格内放2粒，第三格内放4粒。还没有到第二十格，一袋麦子已经空了。一袋又一袋的麦子被扛到国王面前来。但是，麦粒数一格接一格飞快增长着，国王很快就看出，即便拿出全国的粮食，也兑现不了他对西塔的诺言。

```javascript
// O(log₂N)
function ologN(num) {
    let i = 1; // 常量不看
    while(i<num) {
        i = i*2; // 随着num的增加， i翻倍=> log₂n * 2  ## 2是常量不影响，所以可以忽略
    }
    return i
}

// O(log₃N)
function ologN(num) {
    let i = 1; // 常量不看
    while(i<num) {
        i = i*3; // 随着num的增加， i翻倍
    }
    return i
}

/* 不管以2为底、3为底、还是10为底，
 * 都可以记作 O(logN)
*/

```



### O( *N*log(N) )

```javascript
function fn(num1, num2) {
    let total = 0;
    let j = 0;
    for (let i =0; i< num1.length; i++) {
        while(j<num) {
            total += i+j;
        	j = j*2; // 随着num的增加， i翻倍
    	}
    }
    return total
}
```





