## Vue.$nextTick

> 接收一个回调函数`callback`，在下一个DOM更新循环结束后执行。

```vue
<template>
  <div>
    <p v-if="show" ref="node">内容</p>
    <button @click="handleShow">显示</button>
  </div>
</template>
<script>
  export default {
    data () {
      return {
        show: false
      }
    },
    methods: {
      handleShow () {
        this.show = true; // 此时 P 节点还没有渲染出来.        
        console.log(this.$refs.node);  // undefined

        this.$nextTick(() => {
          console.log(this.$refs.node);  // <p>内容</p>
        });
      }
    }
  }
</script>

```



## Vue.set

> 向响应式**对象** 中添加一个属性，并确保视图也会更新！
>
> - 全局方式：Vue.set ( target, propertyName, value )；
>- 实例方式：this.$set ( target, propertyName, value )；

![set_img](C:\Users\wilson\Desktop\博客先写在这，再传到语雀\images\vueImg\set_img.png)

```vue
<template>
  <div class="home">
    <h1>
      <slot name="title">{{ msg }}</slot>
    </h1>

    <section class="field">
      <input v-model.number="price" />
      <button @click="onConfirm">确定</button>
    </section>

    <section class="content">
      <ul v-if="list.length">
        <li v-for="(item, index) of list" :key="index">
          {{ item.name }} {{ item.price | capitalize }}
        </li>
      </ul>
      <p v-else>暂无数据</p>
    </section>
  </div>
</template>

<script>
export default {
  name: "home",
  props: {
    msg: {
      type: String,
      default: "Hello Welcome to Vue.js!",
    },
  },
  created() {
    this.initData();
  },
  data() {
    return {
      price: "",
      list: [],
    };
  },
  methods: {
    // 初始化数据
    async initData() {
      const res = await this.getData();
      this.list = res;
    },
    getData() {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve([{ name: "iMac" }, { name: "iPhone" }]);
        }, 1000);
      });
    },

    /**
     * 确认
     */
    onConfirm() {
      this.list.forEach((v) => {
        // v.price = this.price;  这里数据是添加了，但视图不会更新
        this.$set(v, 'price', this.price); // 数据和视图都变了
      });
      console.log("this.list", this.list);
    },
  },
  // 过滤器
  filters: {
    capitalize(val) {
      return val < 10000 ? `$${val}` : `￥${val}`;
    },
  },
};
</script>

<style lang="scss" scoped>
.home {
  .field {
    input {
      margin-right: 4px;
    }
  }
  .content {
    li {
      font-size: 1.5rem;
    }
  }
}
</style>

```



## vm.$on 与 vm.$emit

`$emit('eventName', params)` 向外派发一个事件。

```
let data = {
	name: "李四",
	age: 18
}
vm.$emit('test', data);
```

`$on('eventName', callback)` 监听事件。

```
vm.$on('test', function (val) { console.log(val) });
```



## $bus

> 通过在Vue原型上添加一个Vue实例作为事件总线，实现组件间相互通信。

```javascript
// main.js
import Vue from 'vue'
Vue.prototype.$bus = new Vue();
```



## vm.$once

> 监听一个自定义事件，只触发一次。

```vue
<!-- 单个元素 -->
<span v-once>This will never change: {{msg}}</span>
```



## vm.$off

> 移除自定义事件监听器。

```vue
vm.$off()                  // 无参数，则移除所有的事件监听器
vm.$off('test')            // 只有事件，则移除该事件所有的监听器
vm.$off('test', callback)  // 移出某个事件回调的监听器
```





## ref 与 $refs

> ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。
>
> 【注】:
>
> - ref 是作为渲染结果被创建的，在初始渲染时无法访问到它们。
> - $refs 不是响应式的，不要试图用它在模板中做数据绑定。
> - 在DOM上使用，则指向DOM元素；在子组件上使用，则指向子组件；

```vue
// 伪代码
// 用于子组件
<template>
  <div class="home">
    <Header ref="header"/>
    <button @click="onHideHeader">隐藏头部栏</button>
  </div>
</template>
<script>
import Header from '@/components/Header'
export default {
    methods: {
        /** $ref的使用： 隐藏头部栏
         * showHeader是子组件内控制显示隐藏的属性
         */
        onHideHeader() {
          this.$refs.header.showHeader = false;
        },
    }
}
</script>

// 用于DOM元素
<template>
  <div class="header">
    <h2 ref="title" v-if="showHeader">我是头部导航栏</h2>
    <button  @click="onTabColor">点我切换颜色！</button>
  </div>
</template>
<script>
import Header from '@/components/Header'
export default {
    methods: {
        onTabColor() {
          const colors = `#${Math.floor(Math.random() * 0xFFFFFF).toString(16)}`
          this.$refs.title.style['color'] = colors;
        }
    }
}
</script>
```

