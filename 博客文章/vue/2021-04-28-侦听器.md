## watch

> 主要用于： 当一个值变了，我要需要做哪些事情。适合用于一个值影响多个值的情景。

- `message` 接受一个string，映射到 methods里面的函数。
- 默认情况下，初始化不立即执行？ 在函数中设置 `immediate:true`  就会立即执行一次。
- `handler` + `deep` 用于在监听的数据是有多个层级的情况下



### 基本使用

```vue
<script>
export default {
  data() {
    return {
      msg: '默认值'
    }
  },
  methods: {
    aaa(val) {
      this.msg = val;
    }
  },
  watch: {
    // 监听 data中的 msg
	msg: {
      message: 'aaa', // 映射到 data中的 aaa()
      immediate: true // 初始化时立即执行一次
    }
  }
}
</script>
```



### 监听多个层级的数据

```vue
<script>
export default {
  data() {
    return {
      msg: '默认值',
      deepMsg: {
        a: {
          b: 'Vue is Goods'
        }
      }
    }
  },
  methods: {
    aaa(val) {
      // 监听最里面的 b值 进而改变 msg!
      this.msg = val.a.b;
    }
  },
  watch: {
    // 监听 data中的 deepMsg
	deepMsg: {
      handler: 'aaa',
	  deep: true // 用于监听当有多个层级的情况
    }
      
    //上面这种写法 如果要监听多个属性，性能开销就很大
    // ，我们可以直接监听对象的属性：
    deepMsg: {
      'deepMsg.a.b': 'aaa' // 映射到aaa()  
  	}
  }
}
</script>
```



### 绑定多个 `handler` ，适合多逻辑的情况：

```vue
<script>
export default {
  data() {
    return {
      msg: '默认值',
      deepMsg: '王花花'
    }
  },
  methods: {
    aaa(val) {
      this.msg = val + '***';
    }
    bbb(val) {
      this.msg = this.msg + '小李';
    }
  },
  watch: [ // 以一个数组的形式监听deepMsg,然后多次改变msg的值
    {
      handler: 'aaa', // 第一个函数改变
    },
    'bbb', //第二个函数改变
    function(val) { // 第三个函数改变
        this.msg = this.msg + '...'
    }]
  }
}
</script>
```

